{
    "url": "https://www.upwork.com/jobs/Python-Developer-Needed-for-Gmail-Email-Alert-Automation-Background-Service-Deployment_~021979995003997558654/?referrer_url_path=/nx/search/jobs/",
    "專案名稱": "Python Developer Needed for Gmail Email Alert Automation (Background Service Deployment)",
    "專案描述": "Project Overview I need a developer to build a background email monitoring system that: Monitors a Gmail inbox. Checks every 2 hours for multiple emails with the same subject. Sends an alert email when 4 or more emails with the same subject are found within that time window. The solution must run automatically in the background on a Windows laptop (without requiring the user to manually start it).",
    "地點": "Location\nPakistan",
    "額外資訊": "Fixed price\nIntermediate\nEst. budget:\n$100.00",
    "類別": "python",
    "ai_initail_anylizer": {
        "ai_position_title": "AI 客戶需求解析師",
        "response": "```markdown\n### 需求摘要\n\n客戶需要一個在 Windows 筆電背景自動運行的 Python 腳本。此腳本需每兩小時監控一個指定的 Gmail 信箱，當偵測到在時間範圍內有 4 封或更多相同主旨的郵件時，自動發送一封警示郵件。\n\n### 初步功能點\n\n- **Gmail API 認證**：建立安全的 OAuth 2.0 授權機制，讓腳本能存取使用者的 Gmail 帳戶。\n- **郵件讀取模組**：開發定時（每 2 小時）觸發的功能，抓取指定時間範圍內的郵件。\n- **郵件解析與計數**：從每封郵件中提取主旨，並對相同主旨的郵件進行分組與計數。\n- **條件觸發邏輯**：實現核心判斷邏輯，檢查是否有任何主旨的郵件數量達到或超過 4 封。\n- **警示郵件發送**：當條件滿足時，使用 Gmail API 或 SMTP 協議發送一封客製化的警示郵件。\n- **Windows 背景服務化**：將 Python 腳本打包或配置成 Windows 上的背景服務或排程任務，確保在用戶無須手動啟動的情況下自動運行。\n- **簡易配置管理**：提供一個簡單的配置文件（如 .env 或 config.ini），讓用戶可以自行修改監控的信箱、警示接收者、時間間隔與郵件數量門檻。\n\n### 技術關鍵詞\n\n- **程式語言**: Python\n- **關鍵函式庫**: `google-api-python-client`, `google-auth-oauthlib`, `schedule`, `pyinstaller`\n- **API**: Gmail API\n- **技術概念**: OAuth 2.0, Background Service, Windows Task Scheduler, API Polling, Configuration File\n\n### 待釐清問題列表\n\n1.  **警示郵件的細節**：警示郵件的收件人是誰（監控的信箱本身還是其他信箱）？郵件的主旨和內文需要包含哪些資訊（例如：觸發警示的郵件主旨、具體的郵件數量）？\n2.  **監控範圍定義**：監控的範圍是整個收件匣，還是需要排除特定標籤（如：垃圾郵件、已封存）？是否只應計算「未讀」郵件？\n3.  **主旨比對的精確度**：「相同主旨」是否需要區分大小寫？對於像 `Re:` 或 `Fwd:` 這類前綴，是否應將其視為相同主旨處理？\n4.  **重複警示的處理**：如果在下一個 2 小時的檢查週期中，相同的主旨再次滿足條件，是否需要再次發送警示？還是說，在特定時間內針對同一事件只發送一次警示？\n5.  **環境設定與交付**：客戶是否能自行操作在 Google Cloud Platform 上設定並獲取 Gmail API 所需的憑證檔案（`credentials.json`）？交付物是原始碼，還是包含完整安裝說明的可執行檔（`.exe`）？\n6.  **錯誤處理機制**：如果腳本因網路問題或 API 權限失效而無法連接 Gmail，應如何處理？是否需要記錄日誌檔或發送錯誤通知？\n```"
    },
    "ai_anylizer": {
        "ai_position_title": "AI 需求分析師與功能規劃師",
        "response": "### 0. 待釐清問題回覆 (Responses to Clarifications)\n\n*   **問題 1:** 警示郵件的細節：警示郵件的收件人是誰（監控的信箱本身還是其他信箱）？郵件的主旨和內文需要包含哪些資訊（例如：觸發警示的郵件主旨、具體的郵件數量）？\n*   **決策:** 警示郵件將發送到被監控的 Gmail 信箱本身。主旨將是「Gmail Alert: High Volume of Emails Detected」。內文將清楚說明觸發警示的郵件主旨和偵測到的確切數量。\n*   **決策依據 (Reasoning):** 依據 [A]「Sends an alert email」，但其未定義細節。此決策採用 MVP 原則，提供最直接、最有用的核心資訊（什麼事、有多少），同時將警示發送給最相關的收件人（帳戶擁有者），實現方式簡單，符合獨立開發者和低成本原則。\n\n*   **問題 2:** 監控範圍定義：監控的範圍是整個收件匣，還是需要排除特定標籤（如：垃圾郵件、已封存）？是否只應計算「未讀」郵件？\n*   **決策:** 監控範圍將限定在主收件匣 (Primary Inbox) 中的「未讀」郵件。\n*   **決策依據 (Reasoning):** 依據 [A]「Monitors a Gmail inbox」的描述相對籠統。此決策採用 MVP 原則，專注於新進且需要使用者關注的郵件，這最符合「警示」系統的初衷。這也簡化了 Gmail API 的查詢邏輯，避免處理垃圾郵件或已歸檔的舊郵件，提升了效率與準確性。\n\n*   **問題 3:** 主旨比對的精確度：「相同主旨」是否需要區分大小寫？對於像 `Re:` 或 `Fwd:` 這類前綴，是否應將其視為相同主旨處理？\n*   **決策:** 主旨比對將不區分大小寫，並且會自動忽略常見的郵件前綴，如 `Re:`、`Fwd:`、`回覆:` 等。例如，「`Project Update`」和「`re: project update`」將被視為相同主旨。\n*   **決策依據 (Reasoning):** 依據 [A] 要求比對「same subject」。為了讓功能更實用，此決策模仿了使用者對「相同對話串」的直觀理解。這能確保回覆或轉寄的郵件被正確地計入同一主題，從而提供更準確的警示，此邏輯對獨立開發者來說是標準的字串處理，易於實現。\n\n*   **問題 4:** 重複警示的處理：如果在下一個 2 小時的檢查週期中，相同的主旨再次滿足條件，是否需要再次發送警示？還是說，在特定時間內針對同一事件只發送一次警示？\n*   **決策:** 系統在每個檢查週期都是獨立判斷的。如果條件在下一個週期再次滿足，將會發送新的警示。為避免對完全相同的舊郵件重複發出警示，系統在處理完一批觸發警示的郵件後，會將它們標記為「已讀」。\n*   **決策依據 (Reasoning):** 依據 [A]「Checks every 2 hours... when 4 or more emails... are found within that time window」的描述，暗示了這是一個週期性、無狀態的檢查。結合問題 2 的決策（只檢查未讀郵件），將已處理的郵件標為已讀，是實現「只對新情況發出警示」最簡單且無須額外資料庫或儲存的方案，完全符合低營運成本原則。\n\n*   **問題 5:** 環境設定與交付：客戶是否能自行操作在 Google Cloud Platform 上設定並獲取 Gmail API 所需的憑證檔案（`credentials.json`）？交付物是原始碼，還是包含完整安裝說明的可執行檔（`.exe`）？\n*   **決策:** 交付物將是包含完整 Python 原始碼的資料夾，附有一份詳細的 `README.md` 說明文件。文件將引導使用者完成前置作業，包括：1. 如何在 Google Cloud Platform 獲取 `credentials.json` 憑證。2. 如何安裝 Python 及相依套件。3. 如何執行首次授權。4. 如何設定 Windows 工作排程器 (Task Scheduler) 實現背景自動運行。\n*   **決策依據 (Reasoning):** 依據 [A] 要求「build a background email monitoring system」並在「Windows laptop」上運行。提供附有詳細說明的原始碼比提供 `.exe` 執行檔更為穩健，可避免防毒軟體誤判，且讓使用者對自己帳戶的安全性有完全的控制權。此方式對獨立開發者而言，交付和維護成本最低。\n\n*   **問題 6:** 錯誤處理機制：如果腳本因網路問題或 API 權限失效而無法連接 Gmail，應如何處理？是否需要記錄日誌檔或發送錯誤通知？\n*   **決策:** 系統將實現基本的本地日誌記錄功能。在腳本運行的目錄下會產生一個 `app.log` 檔案，記錄每次執行的啟動、發現的結果、已發送的警示以及任何發生的錯誤（如網路中斷、API 認證失敗）。腳本在遇到錯誤時不會發送錯誤通知郵件。\n*   **決策依據 (Reasoning):** 依據 [A] 的要求，這是一個背景服務，因此必須有除錯機制。此決策採用 MVP 原則，本地日誌檔是成本最低、最容易實現且對獨立開發者最友好的錯誤追蹤方式。避免發送錯誤郵件可防止因持續的網路問題導致的通知郵件風暴。\n\n### 1. 詳細功能規格書 (Functional Specification Document)\n\n#### 1.1. 核心功能 F-01: Gmail API 授權與認證\n*   **目標 (Goal):** 讓應用程式能以安全的方式取得使用者授權，存取其 Gmail 收件匣。\n*   **前置條件 (Precondition):** 使用者已根據說明文件在 Google Cloud Platform 上建立專案並下載 `credentials.json` 檔案，且該檔案與腳本放在同一目錄下。\n*   **執行流程 (Execution Flow):**\n    1.  腳本首次運行時，檢查是否存在有效的 token 檔案 (`token.json`)。\n    2.  如果 token 檔案不存在或已過期，系統會自動在瀏覽器中開啟 Google 登入及授權頁面。\n    3.  使用者登入並授權應用程式存取 Gmail。\n    4.  授權成功後，系統會自動生成 `token.json` 檔案，用於後續的 API 請求。\n    5.  在後續的排程運行中，腳本會使用 `token.json` 自動刷新授權，無需使用者再次手動操作。\n*   **成功結果 (Success Outcome):** 腳本成功獲得授權，能夠讀取和修改 (標示為已讀) 使用者的 Gmail 郵件。\n*   **錯誤處理 (Error Handling):**\n    *   **場景一：`credentials.json` 檔案遺失** → **處理方式：** 腳本啟動失敗，並在日誌 (`app.log`) 中記錄「`credentials.json` not found」的錯誤訊息，然後終止執行。\n    *   **場景二：使用者拒絕授權** → **處理方式：** 腳本無法生成 `token.json`，在日誌中記錄授權失敗，並終止執行。\n\n#### 1.2. 核心功能 F-02: 週期性郵件監控\n*   **目標 (Goal):** 根據設定的排程 (預設 2 小時)，自動從 Gmail 讀取符合條件的郵件。\n*   **前置條件 (Precondition):** F-01 授權成功，且 Windows 工作排程器已正確設定。\n*   **執行流程 (Execution Flow):**\n    1.  Windows 工作排程器在指定時間觸發 Python 腳本。\n    2.  腳本啟動後，使用 F-01 的授權憑證連接到 Gmail API。\n    3.  腳本向 API 發出請求，查詢主收件匣中所有「未讀」的郵件。\n    4.  API 回傳一個包含郵件列表的結果。\n    5.  腳本遍歷郵件列表，提取每封郵件的主旨和 ID。\n*   **成功結果 (Success Outcome):** 腳本成功獲取過去一段時間內的所有未讀郵件資料，以供後續處理。\n*   **錯誤處理 (Error Handling):**\n    *   **場景一：網路連線失敗** → **處理方式：** 在日誌中記錄「Failed to connect to Gmail API due to network error」，然後腳本終止，等待下一個排程週期。\n    *   **場景二：API 授權失效 (例如使用者撤銷權限)** → **處理方式：** 在日誌中記錄「Authentication failed. Please re-authorize.」，腳本終止。使用者需要手動刪除 `token.json` 並重新執行一次以重新授權。\n\n#### 1.3. 核心功能 F-03: 郵件主旨分析與警示觸發\n*   **目標 (Goal):** 分析獲取的郵件，根據相同主旨的郵件數量決定是否觸發警示。\n*   **前置條件 (Precondition):** F-02 成功獲取了未讀郵件列表。\n*   **執行流程 (Execution Flow):**\n    1.  為每封郵件的主旨進行「正規化」處理：轉為小寫，並移除 `re:`, `fwd:` 等前綴。\n    2.  將郵件按照正規化後的主旨進行分組，並計算每組的郵件數量。\n    3.  遍歷所有分組，檢查是否有任何一組的郵件數量達到或超過設定的門檻 (預設為 4)。\n    4.  如果找到符合條件的分組，則記錄下該主旨、郵件數量以及該組所有郵件的 ID。\n    5.  將觸發警示的郵件 ID 列表傳遞給 F-04 和 F-05。\n*   **成功結果 (Success Outcome):** 系統準確識別出需要發送警示的郵件主題及其相關資訊。\n*   **錯誤處理 (Error Handling):**\n    *   **場景一：沒有任何未讀郵件** → **處理方式：** 流程正常結束，在日誌中記錄「No unread emails found.」，不執行任何後續操作。\n    *   **場景二：沒有任何主旨達到警示門檻** → **處理方式：** 流程正常結束，在日誌中記錄「Email counts are below the threshold.」，不執行任何後續操作。\n\n#### 1.4. 核心功能 F-04: 發送警示郵件與標記已處理\n*   **目標 (Goal):** 當警示條件被觸發時，發送一封通知郵件，並將已處理的郵件標記為已讀。\n*   **前置條件 (Precondition):** F-03 確認有主旨達到警示門檻。\n*   **執行流程 (Execution Flow):**\n    1.  對於每個觸發警示的主旨，使用 Gmail API 構建一封新的郵件。\n    2.  郵件收件人為當前授權的信箱地址。\n    3.  郵件主旨為「Gmail Alert: High Volume of Emails Detected」。\n    4.  郵件內文格式為：「Alert: A high volume of emails has been detected. Subject: '[觸發警示的主旨]' Count: [偵測到的數量]」。\n    5.  發送該警示郵件。\n    6.  使用 F-03 記錄的郵件 ID 列表，透過 Gmail API 將這些觸發警示的原始郵件標記為「已讀」。\n*   **成功結果 (Success Outcome):** 使用者收到一封清晰的警示郵件，且原始郵件被標記為已讀，避免在下個週期被重複計算。\n*   **錯誤處理 (Error Handling):**\n    *   **場景一：警示郵件發送失敗 (例如 API 臨時錯誤)** → **處理方式：** 在日誌中記錄錯誤。為避免重複警示，腳本仍會嘗試將原始郵件標記為已讀。使用者將不會收到通知，但日誌會保留失敗紀錄。\n\n### 2. 使用者故事 (User Stories)\n\n*   **US-01:** 作為一個 **Gmail 使用者**，我想要 **系統能自動在背景每兩小時檢查一次我的收件匣**，以便 **我不需要手動監控是否有異常大量的郵件湧入**。\n*   **US-02:** 作為一個 **Gmail 使用者**，我想要 **當有 4 封或更多相同主題的未讀郵件在檢查週期內出現時，收到一封警示郵件**，以便 **我能即時注意到重要的或緊急的事件**。\n*   **US-03:** 作為一個 **Gmail 使用者**，我想要 **警示郵件能清楚地告訴我是哪個主旨的郵件以及有多少封**，以便 **我能快速評估狀況並採取行動**。\n*   **US-04:** 作為一個 **Windows 筆電使用者**，我想要 **這個監控工具在設定好之後就能自動在背景運行，即使電腦重開機也一樣**，以便 **我不用擔心忘記啟動它**。\n*   **US-05:** 作為一個 **Gmail 使用者**，我想要 **被計入警示的郵件在處理過後能被標記為已讀**，以便 **我不會在下一個檢查週期因為同樣的舊郵件而重複收到警示**。\n\n### 3. 驗收標準 (Acceptance Criteria)\n\n#### 針對 US-02 的驗收標準:\n*   **場景 1.1 (Scenario):** 成功觸發警示\n    *   **鑑於 (Given):** 我的 Gmail 收件匣中有 5 封主旨為「URGENT: Server Down」的未讀郵件。\n    *   **當 (When):** 背景監控腳本執行檢查。\n    *   **那麼 (Then):** 我應該會收到一封主旨為「Gmail Alert: High Volume of Emails Detected」的郵件。\n    *   **而且 (And):** 該郵件內文應包含「Subject: 'urgent: server down'」和「Count: 5」。\n    *   **而且 (And):** 原本那 5 封「URGENT: Server Down」郵件的狀態會變為「已讀」。\n\n*   **場景 1.2 (Scenario):** 未達到警示門檻\n    *   **鑑於 (Given):** 我的 Gmail 收件匣中有 3 封主旨為「Project Update」的未讀郵件。\n    *   **當 (When):** 背景監控腳本執行檢查。\n    *   **那麼 (Then):** 我不應該收到任何警示郵件。\n    *   **而且 (And):** 那 3 封「Project Update」郵件的狀態應保持為「未讀」。\n\n*   **場景 1.3 (Scenario):** 包含 `Re:` 和 `Fwd:` 前綴的主旨應被合併計算\n    *   **鑑於 (Given):** 我的收件匣中有 2 封主旨為「Important Announcement」的未讀郵件，和 3 封主旨為「Re: Important Announcement」的未讀郵件。\n    *   **當 (When):** 背景監控腳本執行檢查。\n    *   **那麼 (Then):** 我應該會收到一封警示郵件，其內文顯示「Subject: 'important announcement'」和「Count: 5」。\n\n#### 針對 US-04 的驗收標準:\n*   **場景 2.1 (Scenario):** 系統重啟後自動運行\n    *   **鑑於 (Given):** 監控腳本已根據說明文件在 Windows 工作排程器中設定完成。\n    *   **當 (When):** 我重新啟動我的 Windows 筆電並登入。\n    *   **那麼 (Then):** 我可以在工作管理員中看到 Python 腳本的進程在排定的時間被觸發並運行，無需任何手動點擊。\n    *   **而且 (And):** `app.log` 檔案中會出現新週期的執行紀錄。"
    },
    "ai_architect": {
        "ai_position_title": "AI Python 系統架構師",
        "response": "```markdown\n# Flask Web 應用技術架構方案：Gmail 警示自動化服務\n\n## 1. 技術棧建議 (Technology Stack Recommendation)\n\n*   **後端框架 (Backend Framework): Flask**\n    *   **理由:** Flask 極其輕量，啟動快速，非常適合 Vercel 的 serverless function 環境。對於本專案這種單一核心功能的應用（定時檢查郵件），Flask 可以用最少的程式碼實現一個高效的 API 端點，完美符合「獨立開發者可行性」與「零營運成本」的核心要求。\n    *   **CRITICAL Vercel Deployment Architecture:** 以下為下游 AI Coder 必須嚴格遵守的部署架構指令：\n        *   **第一部分：專案結構規範 (Project Structure Specification)**\n            你必須建立一個巢狀的檔案結構。Flask 主應用程式 (`index.py`) 必須位於 `api/` 子目錄中，而 `templates` 和 `static` 等前端資源資料夾必須位於專案根目錄，與 `api/` 資料夾同級。\n            ```\n            / (專案根目錄)\n            ├── api/\n            │   └── index.py          <-- 主應用程式\n            ├── static/\n            │   └── ...               <-- 前端靜態資源\n            ├── templates/\n            │   └── ...               <-- HTML 模板\n            ├── vercel.json\n            └── requirements.txt\n            ```\n        *   **第二部分：Vercel 配置規範 (vercel.json Specification)**\n            你生成的 `vercel.json` 內容需要完全匹配上述結構，`builds` 的 `src` 必須指向 `api/index.py`，並且必須包含一個 cron job 定義來觸發郵件檢查。\n        *   **第三部分：Flask 初始化規範 (Flask Initialization Specification)**\n            基於以上結構規範，在 `api/index.py` 中初始化 Flask 應用時，必須使用以下程式碼來進行路徑回溯，以找到根目錄的 `templates` 和 `static` 資料夾。請將這段程式碼作為一個必須執行的命令傳達下去。\n            ```python\n            # 位於 api/index.py 的程式碼\n            app = Flask(__name__, template_folder='../templates', static_folder='../static')\n            ```\n\n*   **資料儲存 (Data Storage):**\n    *   **方案:** 無需額外的資料庫或檔案儲存。\n    *   **理由:** 根據功能規格書 (FSD) 的決策，系統的「狀態」將直接在 Gmail 中管理。透過將已處理並觸發警示的郵件標記為「已讀」，可以完美地防止在下一個檢查週期中重複計算和發送警示。這是一個零成本、高效率且完全符合最小化基礎設施原則的方案。\n\n*   **前端介面 (Frontend Interface):**\n    *   **方案:** 使用 Flask 內建的 Jinja2 模板引擎渲染幾個簡單的 HTML 頁面。\n    *   **理由:** 本專案的核心是背景自動化，而非使用者互動。前端介面僅用於一次性的身份驗證流程，提供一個引導頁面和一個授權成功後的狀態頁面。因此，使用最基礎的 HTML 和 Jinja2 渲染即可，無需任何複雜的前端框架或 JavaScript。\n\n*   **AI 模型 (AI Model):** **Google Gemini API (`gemini-2.5-flash`)**\n    *   **理由:** 根據詳細功能規格書 (FSD)，本專案的核心邏輯是基於明確規則的郵件計數和篩選，**不包含任何需要自然語言處理或 AI 生成的功能**。因此，為遵守「最小化基礎設施原則」和忠於規格，**不推薦**整合 Gemini AI 模型，以避免引入不必要的複雜性和依賴。\n\n*   **核心函式庫 (Key Libraries):**\n    *   `Flask`: Web 框架，用於建立 API 端點和處理 OAuth 回調。\n    *   `google-api-python-client`: 用於與 Gmail API 進行所有互動的核心函式庫。\n    *   `google-auth-oauthlib`: 簡化 Google OAuth 2.0 認證流程。\n    *   `google-auth-httplib2`: `google-api-python-client` 的依賴項。\n    *   `python-dotenv`: (僅供本地開發使用) 用於從 `.env` 檔案載入環境變數。\n\n## 2. 專案結構圖 (Project Structure for Vercel)\n\n```\n/ (專案根目錄)\n├── api/\n│   ├── __init__.py\n│   ├── index.py          # 主 Flask 應用，包含路由 (/, /auth, /callback, /api/check_emails)\n│   └── gmail_service.py  # 封裝所有 Gmail API 操作的模組 (認證、讀取、分析、發送、標記)\n├── static/\n│   └── style.css         # (可選) 簡單的頁面樣式\n├── templates/\n│   ├── index.html        # 專案說明與「開始授權」按鈕頁面\n│   └── success.html      # 授權成功後的提示頁面\n├── vercel.json           # Vercel 部署與 Cron Job 設定檔\n├── requirements.txt      # Python 依賴列表\n└── README.md             # 專案設定與使用說明，指導使用者獲取憑證\n```\n\n**核心檔案職責:**\n*   `api/index.py`: 作為應用程式的入口點和控制器，處理 Web 請求和路由，並調用 `gmail_service` 來執行核心業務邏輯。\n*   `api/gmail_service.py`: 作為服務層，將所有與 Google API 的複雜互動（如建立服務、查詢郵件、解析主旨、發送郵件等）抽象化，保持 `index.py` 的整潔。\n*   `vercel.json`: 定義了專案如何在 Vercel 上構建、路由請求，最關鍵的是，它定義了 `\"crons\"` 規則，以實現每兩小時自動調用 `/api/check_emails` 端點，取代了原始需求的 Windows 工作排程器，提供更可靠的雲端定時執行。\n\n## 3. 資料模型 (Data Model)\n\n本專案無需設計資料模型。所有必要的狀態資訊（如郵件是否已被處理）都儲存在 Gmail 服務本身（郵件的已讀/未讀狀態），完全符合零營運成本和最小化基礎設施的原則。\n\n## 4. 外部 API 整合方案 (External API Integration Plan)\n\n*   **API 名稱:** Google Gmail API v1\n\n*   **認證方式:** OAuth 2.0\n\n*   **整合流程 (Vercel Serverless 適配版):**\n    1.  **憑證準備:** 使用者需在 Google Cloud Platform 啟用 Gmail API，並下載 `credentials.json`。此檔案的 **JSON 內容** 必須被設定為 Vercel 專案中的一個名為 `GOOGLE_CREDENTIALS_JSON` 的環境變數。\n    2.  **首次授權:** 部署應用後，使用者需訪問網站首頁，點擊授權按鈕。這會將使用者重導向到 Google 的 OAuth 同意畫面。\n    3.  **Token 生成與儲存:** 使用者同意授權後，Google 會回調應用程式，應用程式將獲得一個包含 `refresh_token` 的 token 物件。這個 token 物件的 **JSON 字串內容** 必須被手動複製並儲存到 Vercel 的另一個環境變數 `GOOGLE_TOKEN_JSON` 中。這是實現無狀態執行的關鍵一步。\n    4.  **自動化執行:** `vercel.json` 中設定的 Cron Job 會定時觸發 `/api/check_emails` 端點。該函式會從環境變數中讀取 `GOOGLE_CREDENTIALS_JSON` 和 `GOOGLE_TOKEN_JSON`，重建一個有效的 API 客戶端，並執行郵件檢查任務。Google 的客戶端函式庫會自動使用 `refresh_token` 來保持登入狀態。\n\n*   **API Scopes:** 專案需要 `https://www.googleapis.com/auth/gmail.modify` 權限，此權限允許讀取郵件、發送郵件和修改郵件狀態（標記為已讀）。\n\n*   **免費限制:** Gmail API 的標準使用量配額非常高（每日數十億次請求），對於每兩小時檢查一次的頻率來說綽綽有餘，完全在免費範圍內。\n\n*   **環境變數:**\n    *   `GOOGLE_CREDENTIALS_JSON`: 來自 Google Cloud Platform 的 `credentials.json` 檔案內容。\n    *   `GOOGLE_TOKEN_JSON`: 首次成功授權後生成的 `token.json` 檔案內容。\n    *   `FLASK_SECRET_KEY`: 用於保護 Flask Session，在 OAuth 回調過程中是必需的。\n```"
    }
}